# Прагматичная архитектура Scala приложений, использующая функциональный подход
## Подоплёка написания данной статьи

В Scala, как и в других тьюринг-полных языках любую программу можно написать множеством способов, с использованием различных подходов. При желании, можно найти даже способ эмулировать поведение goto. Но при практическом использовании Scala группой разработчиков часто желательно, что бы один разработчик при необходимости мог в адекватное время исправить программу другого. А для этого желательно, что бы первый разработчик мог в ней разобраться. А для этого было бы здорово, что бы подходов, которые используют разные участники команды, было не очень много. В идеале код, реализующий одну и ту же функциональность, должен писаться разными разработчиками одинаково.

Для этого попробуем описать прагматичную архитектуру внутреннего устройства Scala-приложений. Понятно, что всем угодить ей не получится, но иметь описание некоторой "архитектуры по умолчанию" выглядит достаточно удобным.

## Краткая историческая справка

Исторически были различные попытки систематизировать и описать удобные подходы к написанию программ. Удобное описание-анализ эволюции архитектурных подходов есть на сайте Herberto Graca https://herbertograca.com/ (перевод одной из статей - на хабре: https://habr.com/ru/articles/427739/ )

1. 1979г.: MVC - идея о разделении кода на части, соответствующие данным (и persistence), отображению и пользовательскому интерфейсу и управлению этими данными
	
2. 2003г.: DDD - идея о том что код должен соответствовать предметной области (а не наоборот, когда предметная область размазана по исходному коду). Идеи об всеобщем описывающем языке, разделении на слои
	
3. 2005г.: Hexagonal (ports & adapters) - Несколько входов и выходов, вводит понятие адаптеров и подразумевает, что адаптеры должны реализовывать интерфейсы портов.
	
4. 2008г.: Onion - добавляет внутренние слои: разбивает бизнес-логику на сервисы приложения, доменные сервисы (т.е. доменную логику, затрагивающую несколько доменных сущностей) и доменную модель
	
5. 2011-2012г.: Clean Architecture - use cases (interactors). screaming architecture (use cases явно говорят, что они делают). явный dependency rule
	
6. 2015-2020г.: scala MTL & TF стиль -> прагматичная архитектура :)
   
За основу нашей прагматичной архитектуры берём Clean Architecture - наболее проработанное развитие Hexagonal Architecture, которая была в свою очередь, развитием идей DDD. Тем не менее концепции из более ранних подходов тоже имеет смысл держать в уме. К примеру, иллюстрация hexagonal архитектуры с сайта Herberto более понятна, чем иллюстрация Clean Architecture (та слишком поднимается слишком высоко).

## Один пакет - одна предметная подобласть

Несмотря на то, что Clean Architecture требует абстрагироваться от инфраструктуры (http, БД), полностью абстрагироваться от неё не получится. Например, возможность падения БД, сети и т.д. часто нужно предвидеть и учитывать (возможно, абстрактно - в виде какого-то обобщённого сбоя) как минимум, в описании логики уровня приложения, а то и доменной модели. При этом, несмотря на то, что полностью вынести инфраструктурную часть невозможно, всё же стоит придерживаться выделения доменной модели за счёт того, что в конкретном классе с помощью абстракции концентрируемся на соответствующей доменной проблеме (не пытаемся, например, реализовать клиент Redis в коде сущностей, которые поддерживают кэширование - этот клиент имеет смысл вынести на сколько-то уровней выше, возможно даже, в библиотеку или другой модуль многопроектного sbt-проекта или монорепы). Также,  пытаемся явно вынести в "доменный код", к примеру, принятие решений. 

Таким образом, основной подход: **каждый пакет** (package) в приложении - это описание какой-то определённой доменной подобласти (в том числе, например, нюансы запросов к внешним системам), хотя есть и пакеты, в которых мы объединяем слабо связанные доменные области - просто что бы не потонуть в сложности. Т.е. выделяем и группируем по принципу доменной общности (вебсервер, который почему-то до сих пор не уехал в сторонний модуль/проект, - в один пакет, описание эндпойнтов и соответствующий интерактор - в другой, роуты для вебсервера - в третий; библиотека для работы с БД в четвёртый пакет, репозитории для работы с БД в ещё один). Если таких доменных общностей оказывается слишком много, то по их обобщающему наименованию (xxx.services/yyy.repositories, где xxx - это доменная подобласть), но никак не по общности способов технической реализации (например, не надо "запихивать все DTO всего приложения в пакет dto").

При разработке "с нуля" выделяем эти отдельные куски постепенно (т.е. не размазываем  код по куче пакетов/модулей/библиотек "на будущее", если не знаем, зачем). Основной критерий выделения - это доменно-семантическая общность того, что выделяем. Избегаем общих названий пакетов вроде "model"/"models", "data", "domain", - вместо них лучше просто использовать имя соответствующего "ограниченного контекста" из DDD. **Т.е. должно быть понятно, по какому принципу (зачем) объединены те или иные классы или объекты**.

В DDD введено понятие Bounded Context. По сути, оно означает разные аспекты в которых могут существовать одноимённые понятия предметной области (например, **Пользователь** в **первоначальной регистрации пользователя** - лиде и **Пользователь** при **оформлении доставки**). Так вот если мы выделяем такие аспекты в нашем приложении, то имеет смысл, что бы подпакеты верхнего уровня в нашем приложении соответствовали Bounded Context, а более глубокие пакеты соответствовали более специфичным доменным общностям.

Например:
* Модель пользователя в запросе на первоначальную регистрацию пользователя и в запросе на доставку товара отличается. В первом случае (можем назвать соответствующий bounded context "registration") нам необязателен пользовательский адрес (или этот адрес может не обязательно быть валидным КЛАДР). Во втором случае (его можно назвать delivery или shipping) этот адрес должен соответствовать требованиям используемых служб доставки.
* Модель, надуваемую из БД "XYZ" можно называть просто "XYZ" или, если вдруг баз у нас много - "[db.XYZ](http://db.XYZ)". Предпочитаем единственное число множественному.
* Стараемся поступать НЕ по принципу супермаркета - т.е. кладём всё для одной семантической сущности/bounded context в один пакет, а не раскидываем case class в одно место, сервисы в другое, адаптеры http в третье.

## Начинаем структурировать - общая структура пакетов

1. На каждом уровне (пакете) приложения должно быть какое-то разделение по смыслу: подкаталоги (подпакеты) это либо конкретные названия концепций, к которой относится (или что реализует/поддерживает) данный уровень, либо название группы таковых концепций (repositories/services), где внутри уже конкретные названия. Предпочитаются более конкретные названия более общим. В частности, следует избегать имён вида domain/model, про которые часто хочется сказать "модель чего?". Конкретные концепции именуются в единичном числе, групповое их название - во множественном.

2. Основная точка входа должна быть на верхнем уровне соответствующего пакета и называться ИмяПриложенияApp или ИмяКомпонента (но не просто "App", "Component" и т.д). Если возникает необходимость выделить полиморфную реализацию точки входа (например, уж очень большие файлы) - то дополнительно добавляем F (ИмяПриложенияF). Вообще, если мы не знаем, куда поместить и как назвать какую-то выделяемую сущность или аспект, то просто повторяем в том же месте её имя и добавляем к нему, что именно выделяем, например, ИмяПриложенияWiring.

3. Базовые классы различных стратегий (или других множественных сущностей) должны кратко называться соответственно сути - например, Request/Response/Validator. Конкретные реализации логично называть с добавлением этого имени (FooRequest, BarResponse, AsdfValidator), но можно и без добавления (Foo, Bar, Asdf), если это помогает выразительности. Недоменные суффиксы (Model, DTO и т.д.) не применяем.

4. Если нужно, каждый уровень должен ссылаться на минимально возможное количество других уровней, не вложенных в него. Чем меньше зависимостей от других уровней - тем, как правило, лучше. **Идеально - зависеть не более чем от пары других классов** (условно: уровня слева и уровня справа, если смотреть на иллюстрацию компонентов приложения с сайта Herberto).

5. Вспомогательный код, который напрямую не связан с доменной областью (например, реализацию особых алгоритмов), уносим в подпакеты пакета **lib** (этот код - потенциальный кандидат на извлечение в отдельные библиотеки или sbt-проекты).

6. Хорошая идея не смешивать термины **requests**/**responses** для driven (secondary) adapters и для driving (primary) adapters. Для driving adapters имеет смысл использовать **commands**/**replies**, **queries**/**answers**

## Спускаемся ниже - на уровень файлов, сигнатур и оформления кода

1. Используем подход "один трейт/класс/объект - один одноимённый файл". Если для класса нужны вспомогательные классы, например, DTO, то описываем их в объекте-компаньоне перед прочими определениями (если граф зависимостей DTO становится развесистым, то выносим в семантически понятный по названию подпакет). Реализацию трейта по умолчанию также обычно кладём в объект-компаньон.

2. Инстансы тайпклассов размещаем в companion object самого тайпкласса или типа, для которого описываем принадлежность к тайпклассу

3. Синтаксис cats и других широко употребляемых либ импортируем весь (\_all.\_), "чужие" же инстансы тайпклассов по необходимости (стараемся что бы эти инстансы не приходилось импортировать вовсе, т.е. ). Если код использует тайпклассы cats.effect, то стараемся не использовать синтаксис из tofu

4. На уровне API (Interactor, Logic) используем более общие сигнатуры ( F\[Either\[SomeError, SomeValue\]\], F\[Option\[SomeValue\]\] ). В реализациях можно использовать монад-трансформеры (EitherT\[F, SomeError, SomeValue\], OptionT\[F, SomeValue\])

5. На уровне API модулей не должны торчать Queue/Topic/Signal и тому подобные примитивы. При необходимости делаем trait-ы типа XXXProducer\[F\]/XXXConsumer\[F\] и смарт-конструкторы для получения пары (XXXProducer\[F\], XXXConsumer\[F\]), причём если неудобно размещать их в отдельных файлах, trait XXXConsumer объявляем в companion object для XXXProducer

